---
layout: page
title: Aranya Product MVP
permalink: "/aranya-product-mvp/"
---

# Aranya Product MVP Spec

## Introduction

A product specification for version 1 of the standalone Aranya daemon and user library. The goal is 
to provide a commercial-off-the-shelf solution for integrating Aranya. Customers should be able to 
download the Aranya daemon and user library, setup a team, and begin using Aranya.

Much of this document will serve as an extension to the [Aranya Beta spec](/docs/aranya-beta.md) 
that was implemented as version beta of the product. To capture all details related to the MVP in a 
single spot, relevant information from the beta spec has been carried into this document below. 

Primary Goals:

1. Provide a low friction solution customers can use to better secure their infrastructure.
2. Easily setup a team and onboard devices.
3. Implement a default policy that works well enough for a wide variety of situations that 
customers can relate to.
4. Provide stable and backwards compatible APIs that allow devices and users to interact with Aranya.
5. Expose an API for point-to-point high performance encrypted communication using IP for  
transport.

Secondary internal goals:

1. Design for the ability to swap out policies in a future version.
2. Design for future improvements, like additional data planes and configurable roles.

A glossary is available in Appendix D.

## Usage Requirements

Aranya is a decentralized message delivery platform with authorization built in. Below are some 
basic requirements for running this version of the product:

System Requirements:

- We will target x86, ARM, and ARM64 running Linux.
  - Must run on Mac for development reasons.
  - ARM (arm32) is in progress, additional work is required to add it to CI. https://github.com/aranya-project/aranya-docs/pull/24/files#r1917143524
- We will assume there is IPv4 or IPv6 connectivity.

Measure the following values to estimate system requirements and include results in this spec.
- Memory usage
- Disk requirements:
  - Storage amount
  - Storage device write speed
  - Storage device seek speed

For a full and up to date list, start with this issue: https://github.com/aranya-project/aranya/issues/62

## Architecture

There will be two subsystems as part of the product:

1. The daemon
2. The client library

The daemon is a standalone process that runs an Aranya instance and exposes the control plane API via IPC. 
It handles setting up all the dependencies that Aranya needs including storage, policy, and network communication.
The daemon will periodically sync with registered peers and handle commands as they are synced. The current design 
does not require that _effects_ are stored on disk. Other implementations have required
effects be stored on disk in case the program is terminated after the effect has been emitted, but before
it has been processed by the daemon or user application. This extends to the shared memory; there is no 
requirement it be preserved between program restarts.

The client library exists inside the device's process and is used to interact with the daemon. The 
client library also includes a light wrapper around QUIC Channels (and similarly for AFC), allowing 
the device to encrypt data and send messages to peers. QUIC channels will provide networking and mostly live
in the client library. Channel setup will require communication with the daemon. Current plans for language bindings
is to initially focus on the C API. The Rust client library is a bonus that we gain from the Rust -> C compilation. The C API 
should include autogenerated docs.

The daemon is able to participate in multiple teams using the same root identity by using some scheme
of generating leaf keybundles per team. This also removes the one-keybundle-per-process requirement.
For MVP we can lay the groundwork for the multi-keybundle approach, and better management of identities
can be added post-MVP or as time allows for MVP.

![daemon subsystems](/docs/images/new_daemon_arch_block.png)

TODO: update diagrams to remove AFC (https://github.com/aranya-project/aranya-docs/issues/6)
![daemon subsystems with additional detail](/docs/images/new_daemon_arch_block_detail.png)

## Config

On startup, the daemon requires a path to the working directory. That directory contains a configuration
file with the path to the unix domain socket that should be created and other values. The daemon working
directory will structured to be compatible with the [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/latest/). Adhering to the XDG Base Directory Specification will increase the interoperability of Aranya
across multiple system configurations.

All other config values are provided when a client context is initialized and passed to the daemon  
over the Unix Domain Socket. This approach allows the device API to drive the configuration of the 
daemon, and can help reduce errors in config mismatch by minimizing the number of duplicate config 
values.

The daemon will expose a simple API that clients can use to request connection information for
dataplanes like AFC. The client will be able to request the AFC config from the daemon and use
that directly. Other configuration values can also be added to this mechanism. After MVP, additional
APIs can be exposed to change those configured values.

A config object will be used to instantiate a graph, i.e. in the action to perform the Init command 
and the API call for adding an existing graph (see CreateTeam and AddTeam APIs below). The config 
object will be versioned and extensible, and should not break API compatibility. 

## Components

The system is made up of multiple components:

The "client API" is the top level component and contains local operations such as
enabling/disabling syncing or initializing a new device.

The Access Control Plane is the top level control plane, enabling IDAM operations
and other on-graph operations. The Access Control Plane is used to manage keys,
address assignment, roles, and labels as set out in the policy which is written in the MVP using 
[version 2.0 of the policy language](/docs/policy-v2.md).

For the MVP, Aranya Quic Channels (maybe called AQC in the future) will be built to provide a simple API for sending and receiving 
messages using a modified Quic transport. The Aranya Quic Channels contains its own control plane 
for control messages, as well as the main data plane for moving data between devices. This is 
similar to Aranya Fast Channels (AFC) from the beta version but with a different underlying 
transport (AFC uses TCP). See [Aranya Quic Channels API](#aranya-quic-channels-api).

Component structure:

- Local Client API: syncing, local device management
  - Access control plane (IDAM control plane): IDAM lifecycle
    - Quic Channels
      - Quic Channels control plane
      - Quic Channels data plane
    - AFC (experimental flag required)
      - AFC control plane
      - AFC data plane
    - Message Broker (later...)
      - Broker control plane
      - Broker data plane
    - On graph messaging (later...)
      - graph messaging control plane (or implicit)
      - data plane (on graph messages)
    - ... additional planes in future versions

Rust features will be used for some features like the raw AFC interface. The goal of this choice is to better signal which APIs are best suited for public use. 

### Client APIs

The client APIs are local-only API endpoints that do not create commands on the graph. They are 
mostly used to manage the local state. Depending on the language, the endpoints may be a different
format that is more idiomatic to that language such as snake_case for C.

- `InitDevice() -> device_id` - init a device if not exists, generate keys, create the API 
instance, etc.
- `GetKeyBundle() -> keybundle` - returns the current device's public key bundle.
- `GetDeviceId() -> device_id` - returns the device's device ID.
- `AddTeam(team_id, config) -> bool` - add an existing team to the local device store. Not an 
Aranya action/command.
- `RemoveTeam(team_id) -> bool` - remove a team from the local device store. Not an Aranya action/
command.
- `SerializeKeyBundle(scheme, keybundle) -> bytes` - serialize a keybundle to a given format/
scheme. Ideally, this can be used to serialize to either human readable or machine readable formats.
- `DeserializeKeyBundle(scheme, bytes) -> keybundle` - desrialize a keybundle from a given format/
scheme.
- `SerializeId(id) -> bytes` - serialize an ID to the standard base58 format. https://github.com/aranya-project/aranya-docs/pull/24/files#r1915516900
- `DeserializeId(bytes) -> id` - deserialize an ID from the standard base58 format. https://github.com/aranya-project/aranya-docs/pull/24/files#r1915516900
- `IsPresent(command_id) -> bool` - looks for command ID in the graph.


#### Sync API

The IDAM control plane will be managed by the daemon process which will be accessed with the APIs 
provided in [IDAM Control Plane API](#idam-control-plane-api) via an IPC mechanism. The daemon will 
be responsible for syncing state with peers. To enable, the APIs below will be provided to add and 
remove peers to sync from.

Unix Domain Sockets and shm will be used for IPC between the daemon and client library. Additional
IPC mechanisms may be explored in the future.

- `AddSyncPeer(address, team_id, config) -> bool` - add a peer to start syncing with at a specific 
rate. Syncing should support DNS resolution in the case a domain name is used. Syncs immediately 
the first time. The config object includes details for authorization (potentially authentication 
too) and options for syncing by pushing or pulling.
- `RemoveSyncPeer(address, team_id) -> bool` - remove a sync peer associated with the given address,
team_id.
- `SyncNow(address, team_id, Option<config>)` - Trigger an immediate sync for the peer. If a sync
config is provided, use that. If no config arg is provided, fallback to the config used when the peer
was added via AddSyncPeer. If the peer was not added, use a default config or error. https://github.com/aranya-project/aranya-docs/pull/24/files#r1917188406


#### Onboarding API

**MVP**:

Easy to implement, key moving is done by integration.

1. Create Device (NewDevice)
2. Get Device Key (Current device KeyBundle (what you give to the admin))
3. Give KeyBundle to admin on team (integration problem)
4. Admin does AddDevice(device_key_bundle)
5. Get team_id from admin (integration detail)
6. Add team_id to client (AddTeam)
7. Sync with device on team (AddSyncPeer)


#### Graph Querying APIs

FactDB queries over the current perspective of the graph should be possible through ephemeral 
commands in the policy that will return query results in their emitted effects. These APIs
are likely to be moved to nice-to-have or Post-MVP, but are currently planned for MVP.

- `QueryFactRole(user_id) -> Role`
- `QueryFactKeybundle(user_id) -> Keybundle`
- `QueryFactNetworkId(user_id) -> network_str`
- `QueryFactLabelAssignments(user_id) -> Vec<label>`
- `QueryFactLabelExists(user_id) -> Vec<label>`


### IDAM Control Plane API

The IDAM control plane is for managing identity and authorization by interacting with the graph. 
Each endpoint creates one or more commands on the graph. The first command in the graph, aka the 
Init command, contains the system's policy that defines the IDAM control plane for bootstrapping.

- `CreateTeam(owner) -> team_id` - initialize the graph, creating the team with the author as the 
owner. Includes policy for bootstrapping.
- `CloseTeam(team_id)` - close the team and stop all operations on the graph.
- `AddDevice(team_id, keybundle, common_name) -> device_id` - add a device to the team with the 
default role
- `RemoveDevice(team_id, device_id)` - remove a device from the team
- `AssignRole(team_id, device_id, role)` - assign a role to a device
- `RevokeRole(team_id, device_id, role)` - remove a role from a device
- `SetNetworkName(team_id, device_id, net_identifier)` - associate a network address to a device 
for use with Quic Channels (or AFC). If the address already exists for this device, it is replaced 
with the new address. Capable of resolving addresses via DNS. For use with CreateChannel and receiving
messages. Can take either DNS name, IPv4, or IPv6. Current implementation uses a bidi map, so we can
reverse lookup.
- `UnsetNetworkName(team_id, device_id, net_identifier)` - disassociate a network address from a 
device.


Custom roles actions (Client APIs for static policy or Control Plane APIs for dynamic policy?). A seperate
spec will be created to better define the new role system.

- `DefineRole(role_name)` - define a new role type that can be assigned to devices
- `ReplaceCommandRole(command_name, authoring_role)` - allow a particular role type to author the 
specified command type
- `ReplaceEntityClass(team_id, device_id, entity_class)` - replace the entity class associated to 
a device
- CLI to manage permissions, etc 

### Aranya Quic Channels API

Draft version: https://github.com/aranya-project/aranya-docs/blob/2-quic-channels/docs/quic-channels.md 
Eventually where the final spec will live: https://github.com/aranya-project/aranya-docs/blob/main/docs/quic-channels.md 

Note: The beta spec describes Aranya Fast Channels (AFC) which is replaced by Aranya Quic Channels 
for the MVP. AFC is instead viewed as an experimental feature of the product which might still be
preferred when running on embedded devices or when using a unidirectional transport. Refer to the 
beta spec and other existing documentation ([AFC](/docs/afc.md) and [AFC-Crypto](/docs/afc-crypto.md)) for more details on AFC. 

Just like AFC, the Quic Channels plane is split in two different sub-planes: the Quic channels 
control plane and the Quic channels data plane. The Quic channels control plane is responsible for 
any Aranya command or ephemeral commands, while the Quic channels data plane contains only data 
related APIs.

Aranya Quic channels use a modified Quic transport implementation that supports the ability to use 
custom cryptography and has latency-based congestion control (see (s2n-quic)[https://github.com/aws/s2n-quic]).

Embedded devices that implement a subset of Aranya library should still be able to sync with
clients that have the full product integrated. AFC should also be compatible between subset implementations
and the full implementation. This compatibility is planned for Post-MVP.


## Roles & Permissions

There will be 4 default roles with the following set of permissions for each. The MVP will also
include an expansion of the role system, allowing the user to create custom roles and reassign
permissions for specific commands to custom roles.

`owner`

- all permissions excluding sending data on channel label
- create/close team
- add/remove devices
- elevate/revoke permissions for devices up to and including `owner`
- define/undefine channel labels
- assign/remove addresses/names for Aranya channels
- assign/revoke channel labels
- sync

`admin`

- elevate/revoke permissions for devices up to a max level of `operator`
- define/undefine channel labels
- assign/remove addresses/names for Aranya channels
- cannot send data on channel labels
- sync

`operator`

- add (new) / rm device in team
- assign member role to devices in team
- assign/revoke channel labels
- assign/remove addresses/names for channel
- cannot send data on channel labels
- sync

`member`

- use Aranya channel
- sync

`sync-role`

- sync

Notes:

- Devices can always remove and demote themselves
- Devices of equal role cannot remove or demote each other (hence, capabilities
of an owner can only be self-reduced)

## Documentation

API documentation must be provided for the client API covering the functions
and behavior of each API call. Most likely, this will take the form of a doxygen-like
web page. Developers can use this to look up language agnostic functions for operating
the client API. The documentation should also include tutorials and a quickstart
to get developers up and running with the product as soon as possible. Documentation
should also be provided for the daemon so that developers and sysadmins can
understand the requirements and operations of the daemon.


# Appendix

## Appendix A: TODOs needed to complete MVP updates

This is a list of things that need to be tracked and accomplished for the MVP. Scope is
subject to change. This list is unordered within the sections.

### Urgent

### High
-  Measure system requirements and record values in this spec. https://github.com/aranya-project/aranya/issues/62
  - Maybe also include some measures on compile time and build requirements
-  Quic channels spec and implementation
-  ARM32 support for CI and releases
-  Expose bytes of IDs to end user

### Normal 
-  Update existing code and docs to use "device" instead of "user".
  -  Ensure "graph" is used in core, while "team" is used in product.
-  Add "ephemeral" marker in command metadata.
-  Take measures to deem AFC as experimental (e.g., updating docs)?
-  Update AddSyncPeer to sync immediately
-  Add config object with just version field to `CreateTeam` and `AddTeam` APIs.
-  Implement `SyncNow`
-  Add config object to `AddSyncPeer` and include the rate parameter in it.
  -  Might want to add max # of bytes to sync, timeout for number of secs it stays open, etc.
-  Update existing AFC APIs to include "afc" in their name to differentiate from Quic channels
-  Custom policy roles spec and implementation
-  Allow a single keybundle to participate in multiple teams via some sort of root-identity-key (or other mechanism)
-  Fact DB queries via session commands

### Low
-  Set up CI to measure resource usage
-  Implement FactDB query APIs
-  CLI for managing permissions
-  Update default policy to have one role type authoring each command

### Nice to have

This list encompasses anything moved to Post-MVP but would be nice to get into the MVP if we have resources.

-  Implement `Finalization`
-  Implement `AwaitCommand` and `IsPresent`.

### Uncategorized

-  Update spec diagrams.
-  Outline and apply daemon working directory changes.
  -  Establish best terminology for reference (e.g. "device store"?).
-  Improve polling mechanism for Quic channels

## Appendix B: Naming Schemes

The C API will use the following naming scheme:
```
(libraryPrefix)_((receiver)_)?(functionName)
```

Where 
- libraryPrefix is a global prefix for the whole library (ex: Aranya)
- receiver is a thing we are calling a function on (see below for example) 
- functionName is the name of the function to call.

For example, an API endpoint with the name `FooClientBar` breaks down as follows:

- `Foo` is the library.
- `Client` is the receiver.
- `Bar` is the function name.

`FooClientBar` calls the function `Bar` on an instance of `Client` (passed as an argument)
provided by the library `Foo`.

### Verb pairs

- Add/Remove
- Assign/Revoke
- Create/Delete
- Set/Unset

## Appendix C: Notes and Post-MVP information

## TODO: Post-MVP (unordered)

Ideally, embedded devices that implement a subset of Aranya library should still be able to sync with
clients that have the full product integrated. AFC should also be compatible between subset implementations
and the full implementation. This compatibility is Post-MVP.

### Peer Config

Include static peer config (e.g., using JSON) so that fewer API calls will 
be needed to set up new devices. https://github.com/aranya-project/aranya-docs/pull/24/files#r1915620683

### Onboarding

We will provide an additional optional onboarding API:

- `CreateInvite(server address, team_id) -> Invite code` - create an invite code that will be sent 
to a device to onboard.
- `PollInvite(server address, Invite Code) -> Option<Device key>` - check the status of an invite  
code, returns the device ID of the device that joined using that code.
- `Join(server address, Invite Code, Device Key) -> Result<team_id>` - join a team using an invite  
code, returns the team_id of the team that was joined.

The goal of this onboarding API is to simplify the process of onboarding a user/device by providing 
an invite code instead of passing a KeyBundle.

### API

- `AwaitCommand(command_id)` - waits until command ID is present in the graph. (Post-MVP)
- `Finalization(team_id)` - create a truncation checkpoint of the graph. Any command received after 
a Finalization must be its descendant, otherwise, it will be dropped. Post-MVP. https://github.com/aranya-project/aranya-docs/pull/24/files#r1927632474
  - TODO: include details on minimal implementation?
  - TODO: add ability to propose command to be added to graph after `n`th finalization. Not needed to support base
      functionality of finalization. https://github.com/aranya-project/aranya-docs/pull/24/files#r1927636245 
- Revisit `SetNetworkName` and `UnserNetworkName`.

For the initial implementation in the beta, AFC control messages should be handled
transparently by the client library. In the future, control messages can be passed
to the device to be manually forwarded to the daemon using a different API.

##### AFC API 

These API endpoints will be moved to behind the experimental flag:

- `CreateAfcLabel(team_id, label)` - create a label
- `DeleteAfcLabel(team_id, label)` - delete a label
- `AssignAfcLabel(team_id, device_id, label)` - assign a label to a device so that it can be used for 
Quic Channels (or AFC)
- `RevokeAfcLabel(team_id, device_id, label)` - revoke a label from a device


TODO (post-mvp): pass policy through Init command config object.

TODO: (post-mvp?) improving AFC polling in rust API. "Different mechanism for Quic channels will be used. Improving the API for AFC specifically is not part of MVP but if improvements are needed for Quic channel then they might happen for MVP - see Quic channels spec." - YC

TODO (post-mvp): add support for other languages.

### Additional Notes

- All Rust APIs use Result unless stated otherwise
- C APIs return the AranyaError type, and use parameters for return values unless
some other pattern is required.



## Appendix D: Glossary

- `AFC` - the library used to do high performance encryption using keys managed by `Aranya`.
- `Aranya Quic Channels (maybe AQC)` - An integration of Aranya with QUIC to provide a secure 
and integrated transport. See QUIC channels spec. TODO(declan): link
- `Aranya` - the main library that drives the control plane and policy execution.
- `daemon` - a long-lived process, typically running in the background, that
handles commands and keeps state.
- `device` - a computer, sometimes associated with a user but can also be independent.
In this model, we consider `devices` instead of users directly to accommodate
autonomous entities.
- `IPC` - inter-process communication.
- `policy` - an Aranya policy, containing the logic and rules of the system.
- `sync` - a request to synchronize the commands on the control plane. Syncs are currently
pull only, so the device that requests a sync receives commands from the requestee.
- `team` - a group of devices with an associated policy.
- `user` - a person who may operate a device.
- `XDG` - A specification for cross-platform interoperability. In this spec, we are referencing the XDG Base Directory Specification https://specifications.freedesktop.org/basedir-spec/latest/

